# üìã **PADR√ïES DE DESENVOLVIMENTO - PROJETO RGRTRASPORTE**

## üéØ **PADR√ïES OBRIGAT√ìRIOS**

### **1. üè≠ Factory Methods para Entidades**

#### **‚úÖ PADR√ÉO CORRETO**
```csharp
public class MinhaEntidade : AggregateRoot
{
    private MinhaEntidade() { } // Para EF Core
    
    private MinhaEntidade(/* par√¢metros */)
    {
        // Valida√ß√µes b√°sicas de integridade
        // Inicializa√ß√£o de propriedades
        // AddDomainEvent se aplic√°vel
    }
    
    // Factory Method principal
    public static MinhaEntidade CriarEntidade(/* par√¢metros */)
    {
        return new MinhaEntidade(/* par√¢metros */);
    }
    
    // Factory Method com valida√ß√£o
    public static (MinhaEntidade?, bool) CriarEntidadeComValidacao(
        /* par√¢metros */,
        INotificationContext notificationContext)
    {
        var validationService = new EntidadeValidationService();
        var valido = validationService.ValidarCriacao(/* params */, notificationContext);
        
        if (!valido)
            return (null, false);
            
        try
        {
            var entidade = CriarEntidade(/* par√¢metros */);
            return (entidade, true);
        }
        catch (DomainException ex)
        {
            notificationContext.AddNotification(ex.Message);
            return (null, false);
        }
    }
}
```

#### **‚ùå EVITAR**
```csharp
// ‚ùå Construtor p√∫blico
public MinhaEntidade(/* par√¢metros */) { }

// ‚ùå Instancia√ß√£o direta
var entidade = new MinhaEntidade();
```

### **2. üìã Specifications Pattern**

#### **‚úÖ PADR√ÉO CORRETO**
```csharp
// Specification simples
public class EntidadePodeSerAtivadaSpecification : ISpecification<MinhaEntidade>
{
    public bool IsSatisfiedBy(MinhaEntidade entidade)
    {
        return !entidade.Ativo && entidade.ValidadePara > DateTime.UtcNow;
    }
    
    public string ErrorMessage => "Entidade n√£o pode ser ativada no momento";
}

// NotificationSpecification para coleta de erros
public class EntidadeDadosBasicosSpecification : NotificationSpecification<(string nome, int valor)>
{
    public override bool IsSatisfiedBy((string nome, int valor) dados)
    {
        return !string.IsNullOrEmpty(dados.nome) && dados.valor > 0;
    }
    
    public override string ErrorMessage => "Dados b√°sicos inv√°lidos";
    
    public override void ValidateAndNotify((string nome, int valor) dados, INotificationContext context)
    {
        if (string.IsNullOrEmpty(dados.nome))
            context.AddNotification("O nome √© obrigat√≥rio");
            
        if (dados.valor <= 0)
            context.AddNotification("O valor deve ser maior que zero");
    }
}
```

### **3. üîß Domain Services para Valida√ß√µes**

#### **‚úÖ PADR√ÉO CORRETO**
```csharp
public class EntidadeValidationService
{
    public bool ValidarCriacao(
        string nome,
        int valor,
        INotificationContext notificationContext)
    {
        var dadosBasicosSpec = new EntidadeDadosBasicosSpecification();
        var dados = (nome, valor);
        
        dadosBasicosSpec.ValidateAndNotify(dados, notificationContext);
        
        return !notificationContext.HasNotifications();
    }
    
    public bool ValidarAtualizacao(
        MinhaEntidade entidade,
        string novoNome,
        INotificationContext notificationContext)
    {
        // Verificar se pode ser editada
        var podeSerEditadaSpec = new EntidadePodeSerEditadaSpecification();
        if (!podeSerEditadaSpec.IsSatisfiedBy(entidade))
        {
            notificationContext.AddNotification(podeSerEditadaSpec.ErrorMessage);
            return false;
        }
        
        // Validar novos dados
        return ValidarCriacao(novoNome, entidade.Valor, notificationContext);
    }
}
```

### **4. üõ°Ô∏è BaseValidator para Commands**

#### **‚úÖ PADR√ÉO CORRETO**
```csharp
public class CriarEntidadeCommandValidator : BaseValidator<CriarEntidadeCommand>
{
    public CriarEntidadeCommandValidator()
    {
        ValidarTextoObrigatorio(RuleFor(x => x.Nome), "nome", 100);
        ValidarIdObrigatorio(RuleFor(x => x.CategoriaId), "categoria");
        ValidarValorPositivo(RuleFor(x => x.Preco), "pre√ßo");
        ValidarEmail(RuleFor(x => x.Email));
        
        RuleFor(x => x.DataVencimento)
            .GreaterThan(DateTime.Today)
            .WithMessage("Data de vencimento deve ser futura");
    }
}
```

#### **‚ùå EVITAR**
```csharp
// ‚ùå AbstractValidator direto
public class MeuValidator : AbstractValidator<MeuCommand>
{
    public MeuValidator()
    {
        // ‚ùå Duplica√ß√£o de l√≥gica de valida√ß√£o
        RuleFor(x => x.Nome)
            .NotEmpty()
            .WithMessage("O nome √© obrigat√≥rio")
            .MaximumLength(100)
            .WithMessage("O nome deve ter no m√°ximo 100 caracteres");
    }
}
```

### **5. üìä Controllers Padronizados**

#### **‚úÖ PADR√ÉO CORRETO**
```csharp
[Route("api/[controller]")]
[ApiController]
public class EntidadeController : AbstractControllerBase
{
    private readonly IMediator _mediator;

    public EntidadeController(
        IMediator mediator,
        INotificationContext notificationHandler)
        : base(notificationHandler)
    {
        _mediator = mediator;
    }

    [HttpGet("{id}")]
    public async Task<IActionResult> ObterPorId(long id)
    {
        var entidade = await _mediator.Send(new ObterEntidadePorIdQuery(id));
        if (entidade == null)
            return await RGRResult(HttpStatusCode.NotFound, $"Entidade com ID {id} n√£o encontrada");

        return await RGRResult(HttpStatusCode.OK, entidade);
    }

    [HttpPost]
    public async Task<IActionResult> Criar([FromBody] CriarEntidadeCommand command)
    {
        var id = await _mediator.Send(command);
        return await RGRResult(HttpStatusCode.Created, id);
    }
}
```

#### **‚ùå EVITAR**
```csharp
// ‚ùå Retornos inconsistentes
public async Task<IActionResult> ObterPorId(long id)
{
    var entidade = await _mediator.Send(new ObterEntidadePorIdQuery(id));
    if (entidade == null)
        return NoContent(); // ‚ùå Inconsistente
        
    return Ok(entidade); // ‚ùå N√£o usa RGRResult
}
```

## üéØ **PADR√ïES DE VALUE OBJECTS**

### **‚úÖ PADR√ÉO CORRETO**
```csharp
public class MeuValueObject
{
    public string Valor { get; private set; } = string.Empty;
    
    private MeuValueObject() { } // Para EF Core
    
    public MeuValueObject(string valor)
    {
        if (string.IsNullOrWhiteSpace(valor))
            throw new DomainException("Valor √© obrigat√≥rio");
            
        if (!ValidarFormato(valor))
            throw new DomainException("Formato inv√°lido");
            
        Valor = valor.Trim().ToUpper();
    }
    
    public static bool ValidarFormato(string valor)
    {
        // L√≥gica de valida√ß√£o
        return !string.IsNullOrWhiteSpace(valor) && valor.Length >= 3;
    }
    
    public override bool Equals(object? obj)
    {
        return obj is MeuValueObject other && Valor == other.Valor;
    }
    
    public override int GetHashCode()
    {
        return Valor.GetHashCode();
    }
    
    public static implicit operator string(MeuValueObject valueObject) => valueObject.Valor;
    public static implicit operator MeuValueObject(string valor) => new(valor);
}
```

## üîß **PADR√ïES DE REPOSITORY**

### **‚úÖ PADR√ÉO CORRETO**
```csharp
public class EntidadeRepository : GenericRepository<MinhaEntidade>, IEntidadeRepository
{
    public EntidadeRepository(IUnitOfWorkContext unitOfWork) : base(unitOfWork)
    {
    }
    
    public async Task<MinhaEntidade?> ObterPorIdComIncludes(long id)
    {
        return await Query()
            .Include(e => e.Categoria)
            .Include(e => e.Itens)
                .ThenInclude(i => i.SubItem)
            .FirstOrDefaultAsync(e => e.Id == id);
    }
    
    public async Task<IEnumerable<MinhaEntidade>> ObterPorCategoriaAsync(long categoriaId)
    {
        return await Query()
            .Include(e => e.Categoria)
            .Where(e => e.CategoriaId == categoriaId && e.Ativo)
            .ToListAsync();
    }
}
```

## üìã **PADR√ïES DE MAPEAMENTO**

### **‚úÖ PADR√ÉO CORRETO**
```csharp
public class EntidadeMapper : Profile
{
    public EntidadeMapper()
    {
        CreateMap<MinhaEntidade, EntidadeDto>()
            // Mapeamento de Value Objects
            .ForMember(dest => dest.CodigoFormatado, opt => opt.MapFrom(src => src.Codigo.Valor))
            .ForMember(dest => dest.DataCriacao, opt => opt.MapFrom(src => src.CreatedAt))
            
            // Mapeamento de propriedades calculadas
            .ForMember(dest => dest.StatusDescricao, opt => opt.MapFrom(src => src.Status.ToString()))
            
            // Ignorar propriedades de navega√ß√£o complexas
            .ForMember(dest => dest.ItensCount, opt => opt.MapFrom(src => src.Itens.Count));
    }
}
```

## üéØ **CHECKLIST DE QUALIDADE**

### **Para Novas Entidades:**
- [ ] ‚úÖ Herda de `AggregateRoot` ou `BaseEntity`
- [ ] ‚úÖ Construtor privado + Factory Methods
- [ ] ‚úÖ Value Objects para tipos complexos
- [ ] ‚úÖ Domain Events quando aplic√°vel
- [ ] ‚úÖ Specifications para regras de neg√≥cio
- [ ] ‚úÖ Validation Service com NotificationContext
- [ ] ‚úÖ M√©todos `ComValidacao` quando aplic√°vel

### **Para Novos Commands:**
- [ ] ‚úÖ Herda de `BaseValidator<T>`
- [ ] ‚úÖ Usa m√©todos do BaseValidator
- [ ] ‚úÖ Mensagens de erro em portugu√™s
- [ ] ‚úÖ Valida√ß√µes espec√≠ficas do dom√≠nio

### **Para Novos Controllers:**
- [ ] ‚úÖ Herda de `AbstractControllerBase`
- [ ] ‚úÖ Usa `RGRResult` consistentemente
- [ ] ‚úÖ Mensagens de erro padronizadas
- [ ] ‚úÖ HTTP status codes corretos

### **Para Novos DTOs:**
- [ ] ‚úÖ Tipos corretos (decimal para coordenadas, etc.)
- [ ] ‚úÖ Propriedades `init` quando aplic√°vel
- [ ] ‚úÖ Valores padr√£o para evitar nullable warnings

## üöÄ **EVOLU√á√ÉO CONT√çNUA**

### **Quando Adicionar Novos Padr√µes:**
1. **Documentar** o padr√£o aqui
2. **Criar exemplos** pr√°ticos
3. **Atualizar** entidades existentes gradualmente
4. **Escrever testes** para validar o padr√£o
5. **Code review** rigoroso

### **Red Flags - Quando Revisar:**
- ‚ùå Reflection em runtime (exceto casos espec√≠ficos)
- ‚ùå Construtores p√∫blicos em entidades
- ‚ùå Valida√ß√µes duplicadas
- ‚ùå Retornos inconsistentes em controllers
- ‚ùå DTOs com tipos incorretos
- ‚ùå Mapeamentos usando `ToString()` inadequadamente

---

## üìö **RECURSOS ADICIONAIS**

- **Architecture Guide**: `docs/Architecture-Guide.md`
- **Performance Guidelines**: `docs/Performance-Guidelines.md`
- **Testing Standards**: `docs/Testing-Standards.md`

---

**üéØ Seguindo estes padr√µes, garantimos c√≥digo consistente, maint√≠vel e escal√°vel!** 